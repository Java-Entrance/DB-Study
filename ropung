# 임시저장

# 4.1 MySQL 엔진 아키텍처
- Mysql 서버는 다른 DBMS에 비해 구조가 상당히 독특하다.
- 사용자 입장에서 보면 거의 차이가 느껴지지 않지만 이러한 독특한 구조 때문에 DBMS에서는 가질 수 없는 엄청난 혜택을 누릴 수 있으며, 반대로 다른 DBMS에서는 문제되지 않을 것들이 가끔 문제가 되기도 한다.

![[Pasted image 20231218145225.png]]


- Mysql은 일반 상용 RDBMS와 같이 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다.
- MySQL 고유의 C API부터 시작해 JDBC나 ODBC, 그리고 .NET의 표준 드라이버를 제공하며, 이러한 드라이버를 이용해 C/C++, PHP, 자바, 펄, 파이썬, 루비나, .NET 및 코볼까지 모든 언어로 MySQL 서버에서 쿼리를 사용할 수 있게 지원한다.

- MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.
- 이책에서는 MySQL의 쿼리파서나 옵티마이저 등과 같은 기능을 스토리지 엔진과 구분하고자 Mysql 엔진과 스토리지 엔진으로 구분했다.
- 그리고 이 둘을 모두 합쳐서 필자는 그냥 MySQL 또는 MySQL 서버라고 표현한다고 한다. 

### Mysql 엔진
- Mysql엔진은 **클라이언트로부터의 접속** 및 **쿼리 요청**을 **처리하는 커넥션 핸들러**와 **SQL 파서 및 전처리기**, **쿼리는 최적화된 실행**을 위한 **옵티마이저**가 중심을 이룬다.
- 또한 Mysql은 표준 SQL 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다.

### 스토리지 엔진
- Mysql 엔진은 요청된 SQL 문장을 문석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행하고, 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다.
- MySQL 서버에서 MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 다음 예제와 같이 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리한다.

```mysql
Create table test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

- 위 예제에서 test-table은 InnoDB 스토리지 엔진을 사용하도록 정의했다.
- 이제 test-table에 대해 INSERT, UPDATE, DELETE, SELECT 등의 작업이 발생하면 InnoDB스토리지 엔진이 그러한 처리를 담당한다.
- 그리고 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.

### 핸들러 API
- Mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다. InnoDB 스토리지 엔진 또한 이 핸들러 API를 이용해 Mysql 엔진과 데이터를 주고받는다. 이 핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지는 SHOW GLOBAL STATUS LIKE 'Handler' 명령으로 확인할수 있다.
### Mysql 스레딩 구조
![[Pasted image 20231218180918.png]]

- Mysql 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.
- Mysql서버에서 실행 중인 스레드의 목록은 다음과 같이 performance_schema 데이터베이스의 threads 테이블을 통해 확인할 수 있다.

### 포그라운드 스레드(클라이언트 스레드)
- 포그라운드 스레드는 최소한 Mysql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시(Tread cache)로 되돌아간다.
- 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정개수의 스레드만 스레드 캐시에 존재하게 한다. 이때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정한다.

- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만 InnoDB테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고,  나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

### 백그라운드 스레드
- MyISAM의 경우에는 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.
	- 인서트 버퍼를 병합하는 스레드
	- 로그를 디스크로 기록하는 스레드
	- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
	- 데이터를 버퍼로 읽어 오는 스레드
	- 잠금이나 데드락을 모니터링하는 스레드
- 모두 중요한 역할을 하지만 그중에서도 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드일 것이다. 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 됐으며, 시스템 변수로 스레드의 개수를 설정한다. InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만 쓰레 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4정도, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.

- 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재돼 있으며, InnoDB또한 이러한 방식으로 처리한다.하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다. 이러한 이유로 InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크 데이터 파일로 완전히 저장 될 때까지 기다리지 않아도 된다. 하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.
	- 사용자가 SELECT 쿼리를 실행했는데 요청된 쿼리를 10분 뒤에 결과를 돌려주겠다 라고 응답 보내는 DBMS는 없다.

### 메모리 할당 및 사용 구조


![[Pasted image 20231218184447.png]]

- Mysql에서 사용되는 메모리 공간은 크게 글로벌 영역과 로컬 메모리 영역으로 구분할 수 있다.
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
- 운영체제의 종류에 따라 다르겠지만 요청된 메모리 공간을 100% 할당해줄 수 있고. 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다. 각 운영체제의 메모리 할당 방식은 상당히 복잡하며, MySQL 서버가 사용하는 정확한 메모리의 양을 측정하는 것 또한 쉽지 않다.
- 그냥 단순하게 Mysql의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각해도 된다.
- 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분되며, 각각 다음과 같은 특성이 있다.

### 글로벌 메모리 영역
- 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.
- 단, 필요에 따라 2개 이상의 메모리 공간을 할다받을 수도 있지만 클라이언트의 스레드 수와는 무관하며, 생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다. 대표적인 글로벌 메모리 영역은 다음과 같다.
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼

### 로컬 메모리 영역
세션 메모리 영역이라고도 표현하며, Mysql 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다. 대표적으로 커넥션 버퍼와 정렬(소트) 버퍼 등이 있다. 클라이언트가 Mysql에 접속하면 Mysql 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다. 클라이언트와 mysql 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 세션 메모리 영역이라고도 표현한다.

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다. 일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하지만 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경쓰지 않고 설정하는데, 최악의 경우에는 MySQL 서버가 메모리 부족으로 멈춰 버릴 수도 있으므로 적절한 메모리 공간을 설정하는 것이 중요하다. 로컬 메모리 공간의 또 한 가지 중요한 특징은 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 Mysql이 메모리 할당조차도 하지 않을 수도 있다는 점이다. 대표적으로 소트 버퍼나 조인 버퍼와 같은 공간이 그러하다. 그리고 로컬 메모리 공간은 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있고(커넥션 버퍼나 결과 버퍼) 그렇지 않고 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간(소트 버퍼나 조인 버퍼)도 있다.
- 대표적인 로컬 메모리 영역은 다음과 같다.
	- 정렬 버퍼(소트 버퍼)
	- 조인 버퍼
	- 바이너리 로그 캐시
	- 네트워크 버퍼



# 트랜잭션
Mysql의 동시성에 영향을 미치는 잠금(락)과 트랜잭션, 트랜잭션의 격리 수준에 대해서 살펴보자.

### 트랜잭션?
- 트랜잭션은 작업의 완전성을 보장해 주는 것
- 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(`Partial update`)이 발생하지 않게 만들어주는 기능이다.

- 잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
- 하나의 회원 정보 레코드를 여러 커넥션에서 동시에 변경하려고 하는데 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 된다.
- 결과적으로 해당 레코드의 값은 예측할 수 없는 상태가 된다.
- 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
- 격리 수준이라는 것은 하나의 트랜잭션 내에서  또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다.
### Partial update?
- 테이블의 특정 로우에 있는 하나 또는 그 이상의 컬럼 값만을 변경하는것을 말한다.
- 전체 로우를 업데이트하는 것이 아니라 선택된 컬럼들에 대해서만 변경을 적용하는 것이다.
- 이는 데이터의 일부만 변경할 때 효율적이며, 네트워크 대역폭과 서버 자원을 절약하는데 도움이 된다.
```sql
UPDATE users
SET meail = 'test@naver.com', phone = '1234567890'
WHERE user_id = 1;
```
- 이러한 구문은 'user_id'가 1인 사용자의 메일과, 폰 걸럼만을 업데이트 한다.

- 효율성
	- 필요한 데이터만 업데이트하기 때문에, 잔체 로우를 업데이트한다
- 네트워크 대역폭 절약
	- 클라이언트와 서버간에 전송되는 데이터 양이 줄어들어 네트워크 부하가 감소한다.
- 성능 개선
	- 데이터베이스 서버의 부하가 줄어들어 전체적인 시스템 성능이 향상된다
- 동시성 제어
	- 전체 로우가 아닌 일부 컬럼만 업데이트 되므로, 다른 프로세스나 트랜잭션에 의해 동시에 접근되는 경우에도 충돌의 가능성이 줄어든다.


## 트랜잭션
---
- MYISAM이나 MEMORY 스토리지 엔진이 더 빠르다고 생각하고 InnoDB 스토리지 엔진은 사용하기 복잡하고 번거롭다 생각하지만 InnoDB가 트랜잭션을 지원하는 처리 방식 차이에 대해서 살펴보고자 하는거같다.

### Mysql에서의 트랜잭션
- 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야함을 보장해 주는 것이다.

- MyISAM은 도중에 실패해도 전체 롤백이 안되고 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다.
- MyISAM테이블에서 발생하는 이러한 현상을 부분 업데이트(Partial Update)라고 표현하며, 이러한 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.


### 글로벌 락
### 테이블 락
### 네임드 락
### 메타데이터 락



## Mysql 격리 수준(isolation level)
- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

### 격리 수준은 크게 4가지로 나뉜다.
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

- DIRTY READ라고도 하는 READ UNCOMMITTED는 일반적인 데이터베이스에서는 거의 사용하지 않고, 
- SERIALIZABLE또한 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.

4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이라고 볼 수 있다.
- 격리 수준이 높아질수록 MySQL 서버의 처리 성능이 많이 떨어질 것으로 생각하는 사용자가 많은데, 사실 SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다.

![[Pasted image 20231226020800.png]]


###  READ UNCOMMITTED
- 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.


### READ COMMITTED
- 오라클 DBMS에서 기본으로 사용되는 격리 수준 온라인 서비스에서 가장 많이 선택되는 격리 수준.
- 더티 리드 같은 현상은 발생하지 않는다.
- COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 떄문이다.

### REPEATABLE READ
- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 Mysql 서버에서는 최소 이 격리 수준 이상을 사용해야 한다.
- InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경되기 전 레코드를 언두(Undo)공간에 백업해두고 실제 레코드 값을 변경한다. 이러한 방식을 MVCC라고 한다
- 이 격리 수준은 언두 영역에 백엽된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.

