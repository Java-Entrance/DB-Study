InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다. 

그리고 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다. 사실 READ COMMITTED도 MVCC를 이용해 COMMIT 되기 전 데이터를 보여준다. 

차이점이라면 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.

### 고유 트랜잭션 번호
모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)을 가지며, *언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 포함*돼 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불 필요하다고 판단하는 시점에 주기적으로 삭제한다.

REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 가 없다. 정확하게는 특정 트랜잭션의 번호의 구간 내에 백업된 언두 데이터가 보존돼야 한다.


### REPEATABLE READ의 SELECT 쿼리는 한 트랜잭션 내부에서만 동작한다.
![[Pasted Image 20231226181751_626.png]]

위 그림은 REPEATABLE READ 격리 수준이 작동하는 방식을 보여준다.
사용자 A의 트랜잭션 번호는 12였으며 B의 번호는 10번이다. 

B가 BEGIN 명령으로 트랜잭션을 시작하면서 10번이라는 트랜잭션 번호를 부여받았는데  그때부터 사용자 B의 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 10보다 자은 트랜잭션 번호에서 변경한 것만 보게된다.

이러한 특성 때문에
한 사용자가 BEGIN으로 트랜잭션을 시작하고 장시간 종료하지 않으면 언두 영역이 백업된 데이터로 무한정 커질수가 있다. 이렇게 되면 MySQL 서버의 처리 성능이 떨어질 수가 있다.

### PHANTOM READ
다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상이다. 
SELECT ... FOR UPDATE 쿼리는 SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, **언두 레코드에는 잠금을 걸 수 없다**.
그래서 SELECT ... FOR UPDATE나 SELECT ... LOCK IN SHARE MODE 로 조회하는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 되는 것.

#### SELECT ... FOR UPDATE : 조회하는 대상을 수정하기 위해 LOCK 을 거는 기능