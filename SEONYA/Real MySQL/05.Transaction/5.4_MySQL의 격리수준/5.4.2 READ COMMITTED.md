
오라클 DBMS에서 기본으로 사용되는 격리 수준이고 온라인 서비스에서 가장 많이 선택된다.

COMMIT된 데이터만 다른 트랙잭션에서 조회할 수 있기 떄문에 더티리드 현상은 나타나지 않는다.

![[Pasted image 20231226175652.png]]

A가 커밋을 수행전 사용자 B가 위 그림 처럼 조회를 하면 조회된 결과는 조회된 사원은 Lara가 나온다. 
READ COMMITTED 격리 수준에서는 어떤 트랜잭션에서 변경한 내용이 커밋 되기 전 까지는 다른 트랙잭션에서 그러한 변경 내용을 조회할 수 없기 때문이다.

그림에서 알수 있듯 B가 조회한 Lara는 언두 영역에 백업된 레코드에서 가져온 것이다. 최종적으로 사용자가 A가 변경된 내용을 커밋하면 Toto라는 참조값을 조회할 수 있다.

### NON-REPEATABLE READ가 왜 발생하고 어떤 문제를 만들어낼 수 있을까?
READ COMMITTED 격리 수준에서도 NON-REPEATABLE READ라는 부정합의 문제가 있다. 아래의 예시는 NON-REPEATABLE READ가 왜 발생하고 어떤 문제를 만들어 낼 수 있는지 보여준다.

![[Pasted image 20231226180445.png]]

별 문제가 없어보일지 모르겠지만 사용자 B가 하나의 트랜잭션 안에서 똑샅은 SELECT쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋난다.

만약 은행과 같은 금전처리와 연결되면 큰 문제가 될 수 있다.
REPEATABLE READ가 보장되지 않기 때문에 총합을 계산하는 SELECT 쿼리는 실행될 때마다 다른 결과를 가져올 것이다. 중요한 것은 사용 중인 트랜잭션의 격리 수준에 의해 실행되는 SQL 문장이 어떤 결과를 가져오는지를 정확히 예측할 수 있어야 한다.

가끔 트랜잭션 내에서 실행되는 SELECT 문장과 밖에서 실행되는 SELECT 문장의 차이를 혼동하는 경우가 있다. READ COMMITTED 격리 수준에서는 차이가 별로 없다 그러나 REPEATABLE READ 격리 수준에서는 기본적으로 SELECT 쿼리 또한 트랜잭션 범위 안에서만 작동한다. 