---
tags:
  - MySQL_Thread
  - MySQL
  - 포그라운드_스레드
  - 백그라운드_스레드
---
## 4.1.2 MySQL 스레딩 구조

 ![이미지 대체 텍스트](../../../attachment/Pasted%20image%20231212220243.png)

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드(Foreground)스레드와 백그라운드(Background) 스레드로 구분할 수 있다. MySQL 서버에서 실행 중인 스레드의 목록은 다음과 같이 performance_schema 데이터베이스의 threads 테이블을 통해 확인할 수 있다.

```mysql
mysql > SELECT 
			thread_id, 
			name, 
			type, 
			processlist_user, 
			processlist_host
		FROM performance_schema,thread 
		ORDER BY type, thread_id
```

 ![이미지 대체 텍스트](../../../attachment/Pasted%20image%20231212221153.png)
전체 44개의 스레드가 실행 중이며, 그중에서 41개의 스레드가 백그라운드 스레드이고 나머지 3개만 포그라운드 스레드로 표시돼 있다. 그런데 이 중에서 마지막 'thread/sql/one_connection' 스레드만 실제 사용자 요청을 처리하는 포그라운드 스레드다. 백그라운드 스레드의 개수는 MySQL 서버의 설정 내용에 따라 가변적일 수 있다. 동일한 이름의 스레드가 2ㅐ 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬로 처리하는 경우다.

```ad-info
여기서 소개하는 스레드 모델은 MySQL 서버가 전통적으로 가지고 있던 스레드 모델이며, MySQL 커뮤니티 에디션에서 사용되는 모델이다. 
MySQL 엔터프라이즈 에디션과 Percona MySQL 서버에서는 전통적인 스레드 모델뿐 아니라 스레드 풀(Thread Pool)모델을 사용할 수도 있다. 
스레드 풀과 전통적인 스레드 모델의 가장 큰 차이점은 포그라운드 스레드와 커넥션의 관계다.

전통적인 스레드 모델에서는 커넥션별로 포그랑누드 스레드가 하나씩 생성되고 할당된다. 하지만 스레드 풀에서는 커넥션과 포그라운드 스레드는 1:1 관계가 아니라 하나의 스레드가 여러 개의 커넥션 요청을 전담한다. 스레드 풀에 대한 자세한 설명은 4.1.9절 '스레드 풀' 절을 참조하자
```

## 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

**포그라운드 스레드**는 최소한 MySQL **서버에 접속된 클라이언트 수 만큼 존재**하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시(Thread cache)로 돌아간다. 

이때 이미 스레드 캐시에 **일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료**시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 된다. 

이때 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정한다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만(MyISAM도 지연된 쓰기가 있지만 일반적인 방식은 아님)InnoDB 테이블은 데이터나 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

```ad-info
MySQL에서 사용자 스레드와 포그라운드 스레드는 똑같은 의미로 사용된다.
클라이언트가 MySQL 서버에 접속하게 되면 MySQL 서버는 그 클라이언트의 요청을 처리해 줄 스레드를 생성해 그 클라이언트에게 할당한다. 이 스레드는 DBMS의 앞단에서 사용자(클라이언트)와 통신하기 때문에 포그라운드 스레드라고 하며, 사용자가 요청한 작업을 처리하기 때문에 스레드라고도 한다. 
```


## 4.1.2.2 백그라운드 스레드
MyISAM의 경우, 별로 해당 사항이 없는 부분이지만 InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼(insert Buffer)를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링 하는 스레드

여기서 가장 중요한 부분은 **로그 스레드**(Log thread)와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 **쓰기 스레드**(Write thread)일 것이다. **MySQL 5.5 버전부터** 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 **2개 이상 지정할 수 있게 됐으며**, innodb_write_io_thread와 innodb_read_io_thread 시스템 변수로 스레드의 개수를 설정한다. InnoDB에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드를 많이 설정할 필요가 없지만, 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4 정도, DAS나 SAN 과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.

#### 요약
- MySQL 5.5 버전부터 읽기,쓰기 스레드 개수를 2개이상 지정 가능
- innodb_write_io_thread와 innodb_read_io_thread 시스템 변수로 스레드의 개수를 설정
- 쓰기 쓰레드는 많은 작업을 백그라운드로 처리
	- 일반 내장디스크일 경우 2~4개정도 설정
	- DAS나 SAN과 같은 스토리지는 디스크를 최적으로 사용할 수 있을만큼 충분히 설정

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다. 그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있으며, InnoDB또한 이런 방식으로 처리한다. 하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다. 이러한 이유로 InnoDB에서는 INSERT,UPDATE,DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다. 하지만 MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

#### 요약
- 일반적인 사용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있다.
	- INSERT,UPDATE,DELETE로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 된다.
- MyISAM은 사용자 스레드(forground thread)가 쓰기작업 까지 함께 처리하도록 설계되어있다.
	- 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.
