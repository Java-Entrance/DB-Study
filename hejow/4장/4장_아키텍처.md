# 4장 아키텍처
- MySQL은 `머리 역할의 엔진`과 `손발 역할의 스토리지 엔진`으로 구성된다.
- 핸들러 API를 만족한다면 누구나 스토리지 엔진을 확장할 수 있다.

## 4.1 MySQL 엔진 아키텍처
- 다른 DBMS와 다른 특이한 구조를 가지고 있다.

![img.png](4장_MySQL_구조.png)

#### 4.1.1.1 MySQL 엔진
- MySQL의 두뇌를 담당한다. 다음 3가지가 중심이 된다.
  1. 커넥션 핸들러 : 접속 및 쿼리 처리
  2. SQL 파서 & 전처리기
  3. 옵티마이저 : 쿼리 최적화
  - 표준 SQL 문법을 지원한다. 동일한 표준 문법을 사용하는 DBMS와 호환된다.

#### 4.1.1.2 스토리지 엔진
- 실제로 데이터를 쓰고 읽는 동작을 수행한다.
- MySQL 엔진은 한개인 반면에 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 특정 테이블에 특정 스토리지 엔진을 지정할 수 있다. 
- 각 스토리지 엔진은 성능 향상을 위해서 키 캐시나 InnoDB 버퍼 풀과 같은 기능을 내장한다.

#### 4.1.1.3 핸들러 API
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때 ***스토리지 엔진에 요청하는 API를 핸들러 API***라고 한다.

### 4.1.2 MySQL 스레딩 구조
- MySQL 서버는 스레드 기반으로 작동한다. *(Foreground & Background)*
> 💡 프로세스 vs 스레드 <br>
> 프로세스 : 메모리에 올라와 연속적으로 실행되고 있는 프로그램 <br>
> 스레드 : 프로세스 내에서 실행되는 작업 단위
- 스레드 수는 설정에 따라 가변적이다. 병렬 처리 중일 경우 동일한 스레드가 등장할 수 있다.

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)
- `MySQL 서버에 접속한 수만큼 존재`하는 스레드로 요청한 쿼리를 처리한다.
- 작업을 마무리 한 뒤 스레드는 다시 캐시로 돌아간다. *(Like Connection Pool)*
- 포그라운드 스레드는 엔진의 버퍼나 캐시에서 먼저 데이터를 확인하고 없다면 직접 디스크나 인덱스 파일에 접근한다.
> 💡 MyISAM vs InnoDB <br>
> MyISAM : 모두 포그라운드 스레드가 처리 <br>
> InnoDB : 버퍼, 캐시까지 포그라운드가 처리, 디스크까지 기록하는 작업은 백그라운드가 처리 

#### 4.1.2.2 백그라운드 스레드
- MyISAM과 다르게 InnoDB의 백그라운드 스레드가 수행하는 작업은 다음과 같다.
  1. Insert Buffer 병합
  2. Log를 디스크로 기록 
  3. InnoDB 버퍼 풀의 데이터를 디스크에 기록
  4. 데이터를 버퍼로 읽어 옴
  5. 잠금이나 데드락을 모니터링
- 이 중에서 당연히 로깅과 디스크에 기록하는 작업이 가장 중요하다.
- 클라이언트 스레드(쿼리 수행)에서 보통 읽기 작업을 처리하기 때문에 많이 할당할 필요는 없다.
- `쓰기 쓰레드는 작업들을 거의 백그라운드에서 처리`하기 때문에 충분히 할당해줘야 한다.
> 💡 DAS? SAN? <br>
> DAS(Direct Attached Storage) : PC나 서버에 USB처럼 연결해서 사용하는 스토리지 <br>
> SAN(Storage Area Network) : 여러 스토리지로 묶인 네트워크
- 일반적으로 쓰기 작업은 지연이 될 수 있다. 따라서 보통 DBMS에서는 지연을 일괄적으로 처리한다.
- 하지만 MyISAM는 `클라이언트 스레드가 쓰기 작업도 같이 처리하기 때문에 지연`이 걸린다. (일반적인 방법으로 지연 처리를 사용할 수 없다.)

### 4.1.3 메모리 할당 및 사용 구조
- MySQL의 메모리는 크게 두 영역으로 나뉜다.
  1. 글로벌 메모리 : OS로부터 할당 받는 영역
  2. 로컬 메모리 (세션 메모리)

#### 4.1.3.1 글로벌 메모리 영역
- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 사용한다. *(Like JVM Heap)*
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역 (세션 메모리 영역)
- 클라이언트 스레드가 `쿼리를 처리할 때 사용하는 영역`이다.
- 스레드 별로 절대로 공유되지 않는 자원이다. *(Like JVM Stack)*
- 변수와 같이 필요할 때만 할당된다. (ex. 쿼리를 실행할 때만 할당하고 해체하는 소트 버퍼 & 조인 버퍼)
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델
- MySQL의 특이한 특징 중 하나이다. 다양한 기능을 플러그인 형태로 지원할 수 있다.
- 쿼리는 엔진에서 대부분 작업(파싱, 옵티마이징, 실행)을 수행하고 읽기/쓰기는 스토리지에서 수행한다.
- 읽기/쓰기 `작업은 1건의 레코드 단위로 수행`한다.
> 💡 핸들러란? 어떤 기능을 호출하기 위해서 운전대 역할을 하는 객체
- 실질적인 `GROUP BY`나 `ORDER BY` 등 복잡한 처리는 `쿼리 실행기`에서 수행한다.

### 4.1.5 컴포넌트
- 8.0부터 기존 플러그인 아키텍처를 대체하기 위해서 컴포넌트 아키텍처가 지원된다.
- 플러그인이 가지는 문제점들은 다음과 같다.
  1. 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신 불가.
  2. MySQL 서버의 변수나 함수를 직접 호출한다.
  3. 상호 의존성을 설정할 수 없다.

### 4.1.6 쿼리 실행 구조
![img.png](4장_쿼리_실행_구조.png)

#### 4.1.6.1 쿼리 파서
- 쿼리 문장을 트리 구조로 변환 한다.
- 여기서 `문법 오류를 찾는다`. 이후 사용자에게 알려준다.

#### 4.1.6.2 전처리기
- 파서에서 만들어진 트리의 `쿼리 문장의 구조적 문제점을 찾는다`.
- `테이블 이름, 칼럼 이름, 내장 함수을 점검`한다.

#### 4.1.6.3 옵티마이저
- 쿼리 최적화를 담당한다. DBMS의 두뇌로 볼 수 있다.

#### 4.1.6.4 실행 엔진
- 각 핸들러에게 받은 결과를 다른 핸들러에게 전달한다. 

#### 4.1.6.5 핸들러 (스토리지 엔진)
- 실행 엔진의 요청을 수행해 `디스크에 데이터를 읽고 쓰는 작업`을 한다.

### 4.1.8 쿼리 캐시
- 쿼리를 캐싱해서 메모리에 저장한다.
- 관련된 레코드가 하나라도 수정되면 모두 삭제해야 하므로 성능 저하를 유발한다.
- 따라서 8.0으로 올라오면서 삭제되었다.

### 4.1.9 스레드 풀
- 엔터프라이즈 버전은 스레드 풀을 지원한다.
- 스레드 풀은 불필요한 자원 소모를 줄이는 것이 목적이다.
- 너무 많다고 좋은 성능을 의미하는 것은 아니다. 오히려 컨텍스트 스위치에 비용이 많이 들어간다.

### 4.1.10 트랜잭션 지원 메타데이터
- 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 딕셔너리 혹은 메타데이터라고 표현한다.
- 이전 5.7 버전까지 파일으로 관리했는데, Command 중에 트랜잭션을 지원하지 않았다.
- `8.0 부터는 파일이 아닌 InnoDB 테이블에 저장`한다. (ex. 시스템 테이블)
> 💡 시스템 테이블? 서버가 동작하는데 기본적으로 필요한 테이블
- 8.0 버전부터 시스템 테이블 모두 InnoDB 핸들러를 사용하고, 시스템 테이블과 메타 데이터 모두 DB에 저장한다. (`mysql.ibd`)
- InnoDB 외의 핸들러를 이용하는 테이블은 SDI(Serialized Dictionary Information) 파일을 이용한다. 직렬화를 위한 포멧이므로 InnoDB 테이블도 변환시킬 수 있다. 

## 4.2 InnoDB 스토리지 엔진 아키텍처
- MySQL 핸들러 중 `유일하게 레코드 기반의 Lock을 지원`한다.
![img.png](4장_InnoDB_구조.png)

### 4.2.1 PK에 의한 클러스터링
- 모든 키들이 PK에 의해서 클러스터링되어 저장된다. *(PK == 클러스터링 인덱스)*
- 쿼리 실행 시 PK가 더 높은 인덱싱 비중을 가진다.
- 하지만 MyISAM 테이블에서는 PK는 단순히 유니크 제약을 가진 세컨더리 인덱스이다.

### 4.2.2 외래 키 지원
- InnoDB 핸들러만 지원하는 기능이다.
- 외래 키가 생성되면 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스가 생성되어야 한다. 따라서 변경이 발생하면 많은 비용이 발생하니 주의해야 한다.

### 4.2.3 MVCC(Multi Version Concurrency Control)
- 일반적인 레코드 수준의 트랜잭션은 DBMS가 지원하는 기능이다.
- MVCC은 `잠금을 사용하지 않는 일관된 읽기를 제공`하는게 목적이다.
- InnoDB에서 MVCC를 `Undo Log`로 이 기능을 구현한다. 
- 여기서 `멀티 버전은 하나의 레코드가 여러 버전으로 관리될 수 있음을 의미`한다.
> 💡 Isolation Level <br>
> 0. Read Uncommited : 어떤 제약 조건도 걸려있지 않는다. 모든 이상 현상이 발생한다. <br>
> 1. Read Commited : Commit된 데이터만 읽는다. `Phantom Read`와 `Non-Repeatable Read`가 발생한다. <br>
> 2. Repeatable Read : 이전 트랜잭션에서 Commit된 데이터만 읽는다. `Phantom Read`가 발생한다. (MySQL의 Default) <br>
> 3. Serializable : ACID 그 자체를 지킨다.
- 수정 한뒤 Commit 하지 않았을 때, `읽기 작업할 때 가져오는 데이터는 격리 수준에 따라 다르다`. 레벨 0이라면 버퍼에 있는 값을 읽을 것이고 그 외라면 `Undo Log`에서 읽어온다.
- 이 과정을 MVCC라고 하고, 트랜잭션의 길이에 따라 Undo Log의 데이터는 무한히 많아질 수 있다.

### 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
- InnoDB는 MVCC를 사용하기 때문에 읽기 작업 시 잠금을 기다리지 않는다.

### 4.2.5 자동 데드락 감지
- InnoDB 핸들러는 내부적으로 `데드락을 관리하기 위해서 Lock을 그래프 형태로 관리`한다.
- 데드락 감지 스레드가 주기적으로 데드락을 찾아 종료한다.
- `종료 순서는 더 적은 Undo Log의 양`이다. 더 적은 Undo Log은 더 적은 롤백(부하)을 의미하기 때문이다.
- 상위 레이어인 MySQL 엔진에서 관리되는 Lock을 볼 수 없어 감지가 불확실할 수가 있다. 특별한 이유가 없다면 시스템 변수 `innodb_table_locks`을 활성화 하자.
- 너무 많은 동시 처리가 발생하는 경우 데드락 감지를 끌 수도 있다. (`innodb_deadlock_detect`)
- 이런 경우는 일정 시간 동안 데드락이 발생했을 때 자동으로 요청을 실패하도록 해야한다. (`innodb_lock_wait_timeout`)

### 4.2.6 자동화된 장애 복구
- InnoDB는 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크 일부만 기록된 데이터 페이즈 등에 대한 복구 작업이 자동으로 이루어 진다.
- 거의 발생할 상황이 아니지만 자동으로 복구할 수 없는 상황에는 MySQL 서버가 자동으로 종료된다. 이후 `innodb_force_recovery` 시스템 변수를 설정해서 시작해야한다. *(p.106 참고)*
- 그래도 시작되지 않는다면 백업을 이용해서 다시 구축해야 한다.

### 4.2.7 InnoDB 버퍼 풀
- `디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시`해두는 공간이다.
- `쓰기 작업을 지연시켜 일괄 작업으로 처리`할 수 있게 해준다. 여러 레코드를 랜덤하게 작업하지 않기 때문에 디스크 작업 횟수를 줄일 수 있다.

#### 4.2.7.1 버퍼 풀의 크기 설정
- 메모리 크기는 OS와 클라이언트 스레드를 고려해야 한다.
- 간혹 레코드 버퍼가 메모리를 상당히 차지하는 경우가 있다. 레코드 버퍼는 `동적으로 할당`되고 전체 커넥션 개수와 커넥션이 사용하는 테이블 개수에 비례하기 때문에 예측하기 어렵다.
> 💡 레코드 버퍼 : 테이블의 레코드를 읽고 쓸 때 사용하는 버퍼 (메모리를 따로 설정 불가능)
- 5.7버전부터 InnoDB 버퍼 풀의 크기를 조절할 수 있다. 상황에 맞게 조절해야 하는데 다음 두가지를 기억하자.
  - 전체 메모리의 50%에서 조금씩 올려가면서 최적점을 찾는다. 
  - 버퍼 풀을 늘리는건 쉽지만 줄이는 것은 어렵다.
- 세마포어로 인한 내부 잠금 경합 문제를 버퍼 풀을 청크 단위(128MB)로 쪼개 해결했다. 크기를 줄이고 늘릴 때 이 단위에 맞춰서 변화한다.
> 💡 세마포어란? 제한(Limit)을 걸어 공유 자원을 접근하게 하는 방법
- 기본적으로 버퍼 풀 인스턴스는 8개로 초기화되고 전체 버퍼 풀의 크기가 1GB 미만이면 1개만 생성된다.

#### 4.2.7.2 버퍼 풀의 구조
- InnoDB는 버퍼 풀을 페이지 크기의 조각으로 쪼개서 핸들러가 필요할 때 데이터 페이지를 읽어 각 조각에 저장한다.
- LRU 리스트, 플러시 리스트, 프리 리스트 3개의 자료 구조를 관리한다.
- Free List는 비어 있는 페이지 목록을 의미한다. `새롭게 디스크에서 읽어온 데이터를 저장`한다. 
- Least Recently Used List는 LRU와 MRU가 결합된 형태이다.
![img.png](4장_LRU_리스트_구조.png)
- Flush List는 동기화되지 않은 데이터 페이지의 `변경 시점 기준의 페이지 목록을 관리`한다.
- 데이터가 변경되면 `Redo Log`에 기록하고 페이지에 반영한다. 여기서 `Redo Log`는 각 페이지와 연결되어 있다.

#### 4.2.7.3 버퍼 풀과 리두 로그
- 버퍼 풀은 데이터베이스의 성능 향상을 위해서 존재한다. 따라서 `버퍼링과 캐시를 지원`한다.
- 단순히 버퍼 풀의 공간만 늘리는 것은 캐시의 성능만 향상시키는 것이다.
- 버퍼링의 향상은 `Redo Log`와 밀접한 관계를 가진다.
- InnoDB에서 로그 파일은 재사용 가능한 공간과 당장 재사용이 어려운 공간으로 나누어 관리한다. 다음 그림에서 화살표를 가진 공간을 의미한다.

![img.png](4장_버퍼풀과_리두로그의_관계.png)
- **당장 재사용이 어려운 공간은 더티 페이지가 있다는 것을 의미**하므로 `활성 리두 로그`라고 부른다.
- 공간은 계속 재사용되며 매번 기록될 때마다 로그 포지션이 증가한다. (`LSN` : Log Sequence Number)
- InnoDB는 주기적으로 체크포인트 이벤트를 발행해서 동기화한다. 시작점은 가장 최근 체크포인트의 LSN이다.
- 체크포인트 이벤트가 발생하면 가장 최근 체크포인트의 LSN보다 작은 LSN은 모두 동기화된다.
- 여기서 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지라고 부른다. (체크포인트 에이지 == 활성 리두 로그 공간의 크기)

#### 4.2.7.4 버퍼 풀 플러시 (Buffer Pool Flush)
- 5.6버전까지는 쿼리 성능에 영향을 주었지만 이후 버전에는 영향이 없다.
- InnoDB에선 플러시 기능을 백그라운드에서 처리한다.

##### 4.2.7.4.1 플러시 리스트 플러시
- 리두 로그 공간을 비우러면 당연히 더티 페이지가 디스크와 동기화되어야 한다.
- 동기화하는 스레드를 `클리너 스레드`라고 한다.
- 상황에 따라 시스템 변수를 조정해가며 최적화를 해야하지만 이는 상당히 번거로운 일이므로 InnoDB는 어뎁티브 플러시를 제공한다.
- 더티 페이지가 생성되는 속도를 분석해서 기존 설정 값에 의존하지 않고 새로운 알고리즘으로 플러시한다.

##### 4.2.7.4.2 LRU 리스트 플러시
- `사용 빈도가 낮은 페이지를 처리`할 때 LRU 리스트 플러시를 사용한다.
- 시스템 변수(`innodb_lru_sacn_depth`)만큼 스캔하며 클린 페이지는 Free List로, 더티 페이지는 동기화한다.

#### 4.2.7.5 버퍼 풀 상태 백업 및 복구
- 버퍼 풀에 데이터가 캐싱되어 있는 상태를 워밍업이라고 표현한다.
- 5.5버전에서는 성능을 위해서 강제로 워밍업을 하는 경우도 있었지만 `5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입`되었다.
- 직접 백업을 시킬 수 있지만 자동화할 수도 있다. (`innodb_buffer_pool_dump_at_shutdown`, `innodb_buffer_pool_load_at_startup`)

#### 4.2.7.6 버퍼 풀의 적재 내용 확인
- 5.6 버전에서는 `information_schema`를 통해서 버퍼 풀의 내용물을 있는지 확인할 수 있었으나 조회 시에 상당한 부하가 발생한다.
- 8.0 버전에서 이 문제를 해결하고자 인덱스를 추가했다.

### 4.2.8 Double Write Buffer
- InnoDB 핸들러는 낭비를 막기 위해서 페이지의 변경된 부분만 기록한다. 여기서 일부만 기록되는 현상이 있는데 이를 `Partial-page` 혹은 `Torn-page`라고 부른다.
- 이 현상을 막기 위해서 Double Write Buffer를 지원한다. 이후 온전하게 플러시가 되면 버퍼를 비운다.
![img.png](4장_double_write.png)
- HDD에선 순차적으로 디스크를 순회하기 때문에 무리가 없지만 SSD 같은 랜덤 IO는 무리가 갈 수 있다.
- 하지만 데이터의 무결성이 중요하다면 도입하는 것이 좋다.

### 4.2.9 Undo Log
- InnoDB는 트랜잭션과 격리 수준을 보장하기 위해서 DML로 변경되기 이전 버전 데이터를 보관한다. 이를 `Undo Log`라고 부른다.

#### 4.2.9.1 언두 로그 레코드 모니터링
- 언두 로그의 데이터는 크게 2가지 용도가 존재한다.
  1. 트랜잭션 롤백용
  2. 높은 동시성
- 5.5 버전에서는 한 번 늘어난 `Undo Log` 공간은 줄어드지 않았다. 하지만 이후 5.7과 8.0 버전에서는 순차적으로 줄이거나 자동으로 줄여주도록 변경되었다.

#### 4.2.9.2 언두 테이블스페이스 관리
- `Undo Log`가 저장되는 공간을 언두 테이블스페이스라고 부른다.
- 5.6 이전에는 시스템 테이블스페이스에서 보관되었는데, 시스템 테이블스페이스는 서버가 초기화될 때 생성되었기 때문에 확장의 한계가 있었다.
- 5.6 버전에서 시스템 변수(`innodb_undo_tablespaces`)를 추가해서 따로 보관할지 아니면 그대로 유지할지 선택할 수 있었다.
- 8 버전 이후에는 이 시스템 변수는 Deprecated 되었고 외부 별도 파일에 기록되도록 개선되었다.
- 한 **언두 테이블스페이스는 1~128개의 롤백 세그먼트**를 가진다. **롤백 세그먼트는 1개 이상의 언두 슬롯**을 가진다.
![img.png](4장_undo_tablespace.png)
- `한 롤백 세그먼트는 InnoDB 페이지 크기를 16byte로 나눈 값의 개수만큼의 언두 슬롯`을 가진다.
- `일반적으로 하나의 트랜잭션에 2개의 언두 슬롯이 필요`하다고 생각하면 된다.
> 😋 최대 트랜잭션의 개수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
- 언두 테이블스페이스 공간을 필요한 만큼만 남기고 나머지를 OS로 반납하는 것을 `Undo tablespace truncate`라고 부른다. 8.0 부터 지원하고 자동&수동 모드가 존재한다.

### 4.2.10 체인지 버퍼
- 레코드가 Insert 혹은 Update될 때 데이터 변경뿐만 아니라 테이블에 포함된 인덱스를 업데이트할 수도 있다.
- 인덱스 업데이트는 랜덤으로 데이터를 읽기 때문에 비용이 많이 발생한다. 만약 수정해야할 인덱스 페이지가 버퍼에 존재한다면 바로 수정하지만, 아니라면 결과부터 반환하고 임시 공간에 저장한다.
- `변경할 데이터를 임시로 보관하는 공간`을 체인지 버퍼라고 부른다.

### 4.2.11 리두 로그 및 로그 버퍼
- 리두 로그는 영속성을 유지시켜주는 안전 장치이다.
- 대부분의 DB는 변경 사항을 로그로 우선 기록한다. 보통 DBMS는 읽기를 더 중요하게 생각하기 때문에 쓰기 작업 시에는 랜덤 엑세스가 필요하다.
- ACID도 중요하지만 성능도 중요하기 때문에 버퍼링을 위한 로그 버퍼도 존재한다.
- 리두 로그 파일의 전체 크기는 버퍼 풀의 성능에 영향을 주기 때문에 중요하다. 

### 4.2.12 어댑티브 해시 인덱스
- 어댑티브 해시 인덱스는 InnoDB 핸들러가 `자주 요청하는 데이터에 대해 자동으로 생성된 인덱스`이다.
- B-Tree의 검색 시간을 줄여주기 위해서 도입된 기능이다. 
- `인덱스 키`와 `데이터 페이지의 주소`의 쌍으로 관리된다. 여기서 `키는 B-Tree 인덱스의 Id와 B-Tree 인덱스의 실제 키 값의 조합으로 생성`된다.
- InnoDB에 어댑티브 해시 인덱스는 단 하나만 존재한다.
- 이전 버전에서는 어댑티 해시 인덱스의 경합이 심했다. 8.0 버전부터는 세마포어 경합을 해결하기 위해서 해시 인덱스 파티션 기능을 제공한다.

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
- 5.5 까지는 InnoDB를 기본 핸들러로 사용하고 그 외에는 MyISAM을 사용했지만, 8.0부터는 InnoDB가 모두 처리한다.

## 4.3 MyISAM 스토리지 엔진 아키텍처
![img.png](4장_MyISAM.png)

#### 4.3.1 키 캐시
- InnoDB의 버퍼 풀과 비슷한 역할을 수행하지만 `인덱스만을 사용`한다.
- 쓰기 작업에 대해서는 부분적으로만 버퍼링을 지원한다.

#### 4.3.2 운영체제의 캐시 및 버퍼
- 인덱스는 키 캐시를 사용할 수 있지만 테이블은 캐시나 버퍼링 기능이 존재하지 않는다.
- 따라서 이런 작업은 OS로 위임한다. 이 때 사용되는 공간을 위해서 MyISAM은 InnoDB와 다르게 공간을 할당해야 한다.

#### 4.3.3 데이터 파일 프라이머리 키(인덱스) 구조
- InnoDB의 PK는 클러스터링되서 관리되지만 MyISAM은 Heap 공간을 활용한다. 즉, PK와 무관하게 Insert 순서대로 데이터 파일에 저장된다.
- 저장되는 레코드는 ROWID라는 물리적인 주소값을 가지고 이 주소값을 포인터로 활용한다.

## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일
- 에러나 경고 메시지가 출력되는 로그 파일이다.
- 설정 파일(my.cnf)에서 `log_error`라는 이름으로 정의된 경로에 생성된다.

### 4.4.2 제너럴 쿼리 로그 파일 (제너럴 로그 파일, General log)
- 쿼리 로그를 활성화하면 모든 쿼리를 확인할 수 있다.
- 파일이 아닌 테이블로도 저장할 수 있다.

### 4.4.3 슬로우 쿼리 로그
- 서비스가 운영 중일 때 쿼리 성능 저하를 판단하는 것은 어렵다. 이 때 사용할 수 있는 것이 슬로우 쿼리 로그이다.
- 특정 시간을 기준으로 잡아 그 이상의 시간 소요된 쿼리를 모두 기록할 수 있다.
